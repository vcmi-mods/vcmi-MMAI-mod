#!/usr/bin/env bash
set -euxo pipefail

# Usage:
#   ./create-release.sh <mod_version>
#
# Example:
#   ./create-release.sh latest
#

MOD_VERSION="$1"

# Keep only major.minor (discard patch)
VCMI_COMPAT=$(jq -r '.compatibility.min | split(".")[0:2] | join(".")' mmai/mod.json)
RELEASE_TAG="vcmi-${VCMI_COMPAT}-${MOD_VERSION}"
REPO="${GITHUB_REPOSITORY}"

cat <<-EOF
Vars:
    GITHUB_REPOSITORY: ${GITHUB_REPOSITORY}
    MOD_VERSION: ${MOD_VERSION}
    VCMI_COMPAT: ${VCMI_COMPAT}
    RELEASE_TAG: ${RELEASE_TAG}
    GITHUB_SHA: ${GITHUB_SHA}
EOF

##############################################################################
# Rename release RELEASE_TAG (if exists)
##############################################################################

if gh release view "${RELEASE_TAG}" -R "${REPO}"; then
    echo "Release with tag ${RELEASE_TAG} exists, will rename it."

    # Get publish date (ISO 8601) of the existing release
    PUBLISHED_AT="$(gh release view "${RELEASE_TAG}" -R "${REPO}" --json publishedAt -q '.publishedAt')"

    if [ -z "${PUBLISHED_AT}" ] || [ "${PUBLISHED_AT}" = "null" ]; then
        echo "Error: existing release has no publishedAt; cannot compute date tag."
        exit 1
    fi

    # Construct new tag for the old release (replace "latest" with the publish date)
    PUBLISHED_TIMESTAMP="$(date -d "${PUBLISHED_AT}" +%Y%m%d%H%M%S)"
    NEW_TAG="${RELEASE_TAG/latest/${PUBLISHED_TIMESTAMP}}"

    if gh release view "${NEW_TAG}" --repo "${REPO}"; then
        echo "Error: a release with tag ${NEW_TAG} already exists. Aborting."
        exit 1
    fi

    # notes=$(command gh release view "${RELEASE_TAG}" --json body --jq .body)
    # new_notes=$(printf "%s\n*Outdated:* %s" "$old_notes" "$(date '+%F %T')")

    # Rename the release
    gh release edit "${RELEASE_TAG}" \
        --repo "${REPO}" \
        --tag "${NEW_TAG}" \
        --title "${NEW_TAG}"
fi

##############################################################################
### Download models
##############################################################################

settings=$(jq '.models = {}' mmai/config/mmai-settings.json)

#
# Models in sources.json will be downloaded and inserted into mmai-settings.json
# Example:
#
#   # models/sources.json:
#   {"attacker": "http://example.com/foo.onnx", "defender": "http://example.com/bar.onnx"}
#
#   # => Files downloaded as models/foo.onnx and models/bar.onnx
#   # => config/mmai-settings.json updated with:
#   {..., "models": {"attacker": "foo.onnx", "defender": "bar.onnx"}, ...
#
while read -r name url; do
  filename="${url##*/}"
  curl --fail -Lo "mmai/models/${filename}" "${url}"
  settings=$(echo "$settings" | jq --arg k "$name" --arg v "$filename" '.models[$k] = $v')
done < <(jq -r 'to_entries[] | "\(.key) \(.value)"' mmai/models/sources.json)

#
# Models in hidden.json will be downloaded only (no changes in mmai-settings.json)
# NOTE: hidden.json is a *list* of urls (as opposed to sources.json which contains key-value pairs)
# These models are optional (list may be empty) and only used for smooth migration after hotfixing
while read -r url; do
  dst="mmai/models/${url##*/}"
  [ -e "$dst" ] && exit 1 || :
  curl --fail -Lo "$dst" "$url"
done < <(jq -r '.[]' mmai/models/hidden.json)

echo "$settings" > 'mmai/config/mmai-settings.json'

##############################################################################
# Create new release with RELEASE_TAG from current HEAD
##############################################################################

notes=$(cat <<EOF
Generated by GHA run [${GITHUB_RUN_ID}](https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID})
EOF
)

latest_ref="refs/tags/${RELEASE_TAG}"
if gh api -X GET "repos/${GITHUB_REPOSITORY}/git/${latest_ref}"; then
    # "latest" tag already exists => "move" it (force retag)
    jq -n --arg sha "$GITHUB_SHA" '{sha: $sha, force: true}' > body.json
    gh api -X PATCH "repos/${GITHUB_REPOSITORY}/git/${latest_ref}" --input body.json
else
    # "latest" tag does not exist yet => create it
    gh api -X POST "repos/${GITHUB_REPOSITORY}/git/refs" -f ref="$latest_ref" -f sha="$GITHUB_SHA"
fi

gh release create "${RELEASE_TAG}" \
    --repo "${REPO}" \
    --target "${GITHUB_SHA}" \
    --verify-tag \
    --title "${RELEASE_TAG}" \
    --notes "${notes}" \

files=(mmai/mod.json)

# Remove unneeded files
rm mmai/models/{sources,hidden}.json

zip -qr mod.zip mmai

files+=(mod.zip)


for f in screenshots/*.png; do
    [ -f "$f" ] || continue  # handle literal '*' if expansion failed
    files+=("$f")
done

gh release upload "${RELEASE_TAG}" "${files[@]}" --repo "${REPO}"
